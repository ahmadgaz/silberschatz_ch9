#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define MAX_FRAMES 10
#define REF_LEN    20   /* length of random reference string */
#define PAGE_MIN   0
#define PAGE_MAX   9    /* pages 0..9 */

/* ---------- fifo state ---------- */

typedef struct {
    int frames[MAX_FRAMES];
    int next;      /* next frame index to replace */
    int faults;
} FIFOState;

/* ---------- lru state ---------- */

typedef struct {
    int frames[MAX_FRAMES];
    int last_used[MAX_FRAMES]; /* time of last use */
    int faults;
} LRUState;

/* ---------- opt state ---------- */

typedef struct {
    int frames[MAX_FRAMES];
    int load_time[MAX_FRAMES];
    int faults;
} OPTState;

/* ---------- helpers ---------- */

/* init all frame slots to empty (-1) */
static void init_frames(int frames[], int n)
{
    for (int i = 0; i < n; i++)
        frames[i] = -1;
}

/* find page in frames, return index or -1 */
static int find_page(int frames[], int n, int page)
{
    for (int i = 0; i < n; i++)
        if (frames[i] == page)
            return i;
    return -1;
}


/* ----- extra printing helpers for tlast / tnext ----- */

/* same width as print_column: n frame chars + 1 extra slot */
static void print_blank_column(int nframes)
{
    for (int i = 0; i < nframes + 1; i++)
        putchar(' ');
}

/* lru: time since last use for each frame (tlast row) */
static void print_lru_tlast_column(const LRUState *s, int nframes, int time)
{
    for (int i = 0; i < nframes; i++) {
        if (s->frames[i] < 0 || s->last_used[i] < 0) {
            putchar(' ');
        } else {
            int dt = time - s->last_used[i];  /* time since last used */
            if (dt < 0) dt = 0;
            printf("%d", dt);
            if (i != nframes - 1) printf(",");
        }
    }
    putchar('.'); /* align with fault column */
}

/* compute fifo rank (1 = oldest) for pages currently in opt frames */
static void compute_opt_fifo_rank(const OPTState *s, int nframes, int rank_out[])
{
    for (int i = 0; i < nframes; i++) {
        if (s->frames[i] < 0) {
            rank_out[i] = 0;
            continue;
        }
        int rank = 1;
        for (int j = 0; j < nframes; j++) {
            if (s->frames[j] < 0) continue;
            if (s->load_time[j] < s->load_time[i])
                rank++;
        }
        rank_out[i] = rank;
    }
}

/* opt: time until next use, or -fifo_rank if never used again */
static void print_opt_tnext_column(const OPTState *s,
                                   int nframes,
                                   int time,
                                   int refs[],
                                   int ref_len)
{
    int rank[MAX_FRAMES];
    compute_opt_fifo_rank(s, nframes, rank);

    for (int i = 0; i < nframes; i++) {
        if (s->frames[i] < 0) {
            putchar(' ');
            continue;
        }

        int page = s->frames[i];
        int dt = -1;

        /* find next use after current time */
        for (int j = time + 1; j < ref_len; j++) {
            if (refs[j] == page) {
                dt = j - time;
                break;
            }
        }

        if (dt >= 0) {
            printf("%d", dt);          /* tnext */
        } else {
            printf("-%d", rank[i]);    /* -(fifo place) if never used again */
        }
        if (i != nframes - 1) printf(",");
    }

    putchar('.'); /* align with fault column */
}

/* print frames as digits (or '.') plus 'F' or '.' for fault */
static void print_column(int frames[], int n, int fault)
{
    for (int i = 0; i < n; i++) {
        if (frames[i] < 0)
            putchar('.');
        else
            printf("%d", frames[i]);
    }
    if (fault)
        putchar('F');
    else
        putchar('.');
}

/* ---------- fifo step ---------- */

static int fifo_step(FIFOState *s, int nframes, int page)
{
    int i;

    /* hit? */
    if (find_page(s->frames, nframes, page) != -1)
        return 0;

    /* miss */
    s->faults++;

    /* free frame? */
    for (i = 0; i < nframes; i++) {
        if (s->frames[i] == -1) {
            s->frames[i] = page;
            return 1;
        }
    }

    /* no free, replace fifo_next */
    s->frames[s->next] = page;
    s->next = (s->next + 1) % nframes;

    return 1;
}

/* ---------- lru step ---------- */

static int lru_step(LRUState *s, int nframes, int page, int time)
{
    int i;

    /* hit? update last_used */
    int idx = find_page(s->frames, nframes, page);
    if (idx != -1) {
        s->last_used[idx] = time;
        return 0;
    }

    /* miss */
    s->faults++;

    /* free frame? */
    for (i = 0; i < nframes; i++) {
        if (s->frames[i] == -1) {
            s->frames[i]     = page;
            s->last_used[i]  = time;
            return 1;
        }
    }

    /* choose least recently used */
    int victim = 0;
    int oldest_time = s->last_used[0];

    for (i = 1; i < nframes; i++) {
        if (s->last_used[i] < oldest_time) {
            oldest_time = s->last_used[i];
            victim = i;
        }
    }

    s->frames[victim]    = page;
    s->last_used[victim] = time;

    return 1;
}

/* ---------- opt step ---------- */

static int opt_step(OPTState *s,
                    int nframes,
                    int page,
                    int pos,          /* current index in ref string */
                    int refs[],
                    int ref_len)
{
    int i;

    /* hit? */
    if (find_page(s->frames, nframes, page) != -1)
        return 0;

    /* miss */
    s->faults++;

    /* free frame? */
    for (i = 0; i < nframes; i++) {
        if (s->frames[i] == -1) {
            s->frames[i] = page;
            s->load_time[i] = pos;
            return 1;
        }
    }

    /* find victim: page with farthest next use (or never used again) */
    int victim = 0;
    int farthest = -1;

    for (i = 0; i < nframes; i++) {
        int p = s->frames[i];
        int next_use = -1;

        for (int j = pos + 1; j < ref_len; j++) {
            if (refs[j] == p) {
                next_use = j;
                break;
            }
        }

        if (next_use == -1) {        /* never used again */
            victim = i;
            farthest = ref_len + 1;  /* bigger than any index */
            break;
        }

        if (next_use > farthest) {
            farthest = next_use;
            victim = i;
        }
    }

    s->frames[victim] = page;
    s->load_time[victim] = pos;

    return 1;
}

/* ---------- main ---------- */

int main(int argc, char *argv[])
{
    if (argc != 2) {
        fprintf(stderr, "usage: %s <num_frames>\n", argv[0]);
        return 1;
    }

    int nframes = atoi(argv[1]);
    if (nframes <= 0 || nframes > MAX_FRAMES) {
        fprintf(stderr, "num_frames must be between 1 and %d\n", MAX_FRAMES);
        return 1;
    }

    /* generate random reference string */
    int refs[REF_LEN];

    srand((unsigned)time(NULL));
    for (int i = 0; i < REF_LEN; i++)
        refs[i] = PAGE_MIN + rand() % (PAGE_MAX - PAGE_MIN + 1);

    printf("page frames  : %d\n", nframes);
    printf("ref length   : %d\n", REF_LEN);
    printf("ref string   : ");
    for (int i = 0; i < REF_LEN; i++)
        printf("%d ", refs[i]);
    printf("\n\n");

    /* init algorithm states */
    FIFOState fifo;
    LRUState  lru;
    OPTState  opt;

    init_frames(fifo.frames, nframes);
    fifo.next   = 0;
    fifo.faults = 0;

    init_frames(lru.frames, nframes);
    for (int i = 0; i < nframes; i++)
        lru.last_used[i] = -1;
    lru.faults = 0;

    init_frames(opt.frames, nframes);
    for (int i = 0; i < nframes; i++)
        opt.load_time[i] = -1;
    opt.faults = 0;

    /* table header */
    printf("Ref  FIFO   LRU    OPT\n");
    printf("--------------------------\n");

    /* simulate all three in lockstep */
    for (int t = 0; t < REF_LEN; t++) {
        int page = refs[t];

        int f_fault = fifo_step(&fifo, nframes, page);
        int l_fault = lru_step(&lru, nframes, page, t);
        int o_fault = opt_step(&opt, nframes, page, t, refs, REF_LEN);

        /* main frame row */
        printf("%3d  ", page);
        print_column(fifo.frames, nframes, f_fault);
        printf("   ");
        print_column(lru.frames, nframes, l_fault);
        printf("   ");
        print_lru_tlast_column(&lru, nframes, t);
        printf("   ");
        print_column(opt.frames, nframes, o_fault);
        printf("   ");
        print_opt_tnext_column(&opt, nframes, t, refs, REF_LEN);
        print_blank_column(nframes);          /* placeholder under FIFO */
        printf("\n");

        /* extra tlast / tnext row */
        // printf("     ");                      /* under Ref column */
        // print_blank_column(nframes);          /* placeholder under FIFO */
        // printf("   ");
        // print_lru_tlast_column(&lru, nframes, t);
        // printf("   ");
        // print_opt_tnext_column(&opt, nframes, t, refs, REF_LEN);
        // printf("\n");
    }

    printf("--------------------------\n");
    printf("faults FIFO = %d\n", fifo.faults);
    printf("faults LRU  = %d\n", lru.faults);
    printf("faults OPT  = %d\n", opt.faults);

    return 0;
}
